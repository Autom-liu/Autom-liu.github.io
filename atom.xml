<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Autom</title>
  
  <subtitle>做一个有思想的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.it120cc.com/"/>
  <updated>2019-06-19T00:53:08.449Z</updated>
  <id>http://www.it120cc.com/</id>
  
  <author>
    <name>Autom liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jquery</title>
    <link href="http://www.it120cc.com/web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/jquery/jquery.html"/>
    <id>http://www.it120cc.com/web开发/前端开发/jquery/jquery.html</id>
    <published>2019-06-19T00:32:39.000Z</published>
    <updated>2019-06-19T00:53:08.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jquery"><a class="markdownIt-Anchor" href="#jquery"></a> JQuery</h1><h2 id="jquery-设计精髓"><a class="markdownIt-Anchor" href="#jquery-设计精髓"></a> JQuery 设计精髓</h2><h3 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h3><blockquote><p><strong>所有的操作符运算符都将转换为函数</strong></p></blockquote><p>如 ： 集合的遍历、集合的中括号操作将转换为函数eq()</p><h3 id="链式操作"><a class="markdownIt-Anchor" href="#链式操作"></a> 链式操作</h3><blockquote><p><strong>可以一次性对同一对象执行多次操作，每次操作都将返回相应DOM的JQ对象</strong></p></blockquote><p>如： 现在要完成以下任务：</p><p>在div.box元素下添加一个p标签，并添加font类，设置innerHTML的值。</p><p>在原生JS中通常需要严格按照四步进行，但在JQ中，一行代码搞定了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生JS的写法：</span></span><br><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span><br><span class="line"><span class="keyword">var</span> op = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">op.innerHMTL = <span class="string">'hello'</span>;</span><br><span class="line">op.className += <span class="string">'font'</span>; <span class="comment">// 最好自己封装一个addClass</span></span><br><span class="line">oBox.appendChild(op);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用了JQ的写法：</span></span><br><span class="line">$(<span class="string">'.box'</span>).append($(<span class="string">'&lt;p/&gt;'</span>).text(<span class="string">'hello!'</span>).addClass(<span class="string">'font'</span>))</span><br><span class="line"><span class="comment">//甚至还可以更多操作都在同一条链上</span></span><br><span class="line">$(<span class="string">'.box'</span>).append($(<span class="string">'&lt;p/&gt;'</span>).text(<span class="string">'hello!'</span>).addClass(<span class="string">'font'</span>)).eq(<span class="number">0</span>).siblings().css(&#123;<span class="attr">background</span>:<span class="string">'#b6a5f4'</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="getter-和-setter-合体"><a class="markdownIt-Anchor" href="#getter-和-setter-合体"></a> getter 和 setter 合体.</h3><p>即JQDOM对象属性的设置和获取都可以用统一的一个函数，</p><p>如设置和获取css属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'box'</span>).css(<span class="string">'font-size'</span>)</span><br><span class="line">$(<span class="string">'box'</span>).css(&#123;transition-delay : <span class="function"><span class="keyword">function</span> (<span class="params">i,curval</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 第i个元素  curval: 当前属性值 （设置每个延迟终于可以很方便啦！）</span></span><br><span class="line">      <span class="keyword">return</span> i*<span class="built_in">parseInt</span>(curval);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="的四种调用方式"><a class="markdownIt-Anchor" href="#的四种调用方式"></a> $() 的四种调用方式</h2><ul><li><p>$(function(){}) :  文档加载完毕执行的函数  等同于原生DOMContentLoaded</p></li><li><p>$(selector,start):  按css选择器选择元素，可以选择从start开始往下确定</p><blockquote><p><strong>这个函数返回是个集合形式</strong></p></blockquote></li><li><p>$(Element) : 将DOM对象转换成可用于JQ操作的JQ对象</p></li><li><p>$(tar,obj) : 创建tar元素，为其设置相应属性obj, 支持的属性包括 <strong>src</strong>  <strong>css</strong> <strong>html</strong> <strong>text width   height   offset   val   <abbr title="传递event.data给事件处理函数*">data</abbr>  还有各种事件属性</strong>等</p></li><li><p>get(index) : 将JQ对象转换为JS对象</p></li></ul><h2 id="jq集合元素筛选和遍历"><a class="markdownIt-Anchor" href="#jq集合元素筛选和遍历"></a> JQ集合元素筛选和遍历</h2><h3 id="eq-first-last"><a class="markdownIt-Anchor" href="#eq-first-last"></a> eq  first  last</h3><ul><li>eq (i) : 选择第i个  相当于item(i) 或 [i]</li><li>first()  ==  eq(0)</li><li>last() == eq(-1)</li></ul><h3 id="filter-not-add"><a class="markdownIt-Anchor" href="#filter-not-add"></a> filter   not   add</h3><ul><li>filter (selector) : 只选择<strong>还包含</strong> selector 选择器指定的元素</li><li>not (selector) :  只选择<strong>不包含</strong> selector 选择器指定的元素</li><li>add( selector ) : 将selector 指定的元素加入到选择集中去</li></ul><h3 id="next-prev-siblings-index"><a class="markdownIt-Anchor" href="#next-prev-siblings-index"></a> next   prev  siblings  index</h3><ul><li>next() :  下一个兄弟   相当于 nextElementSibling</li><li>prev() :  上一个兄弟    相当于   previousElementSibling</li><li>siblings([selector])  除自身外的其他兄弟  也可以通过[selector]扩展“自身”范围（同辈）</li><li>index() : 返回索引值  表示在所有兄弟中的位置</li></ul><h3 id="has-children-find"><a class="markdownIt-Anchor" href="#has-children-find"></a> has    children   find</h3><ul><li>has( selector ) : 匹配<strong>有后代元素</strong>的元素  这个后代元素需要用selector指定</li><li>children([selector]) :   选择所有子元素（不是后代）</li><li>find (selector) : 找 由  selector 指定的后代元素</li></ul><h3 id="parent-offsetparent"><a class="markdownIt-Anchor" href="#parent-offsetparent"></a> parent   offsetParent</h3><ul><li>parent () :</li><li>offsetParent() :</li></ul><h3 id="each-map"><a class="markdownIt-Anchor" href="#each-map"></a> each  map</h3><ul><li><p>each (function(index,ele))   <em>ele 也可以用this 选择器</em></p></li><li><p>map (function(index,ele))</p><blockquote><p><strong>两者不仅可以是JQ对象的遍历，还可以用于原生JS集合的遍历</strong></p><p><strong>两者的区别在于:  each返回的一定是原JQ对象，但map 会创建一个新对象返回也就是说map可以有返回值哦</strong></p></blockquote></li></ul><h2 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h2><h3 id="class-操作-hasclass-add-remove-toggle"><a class="markdownIt-Anchor" href="#class-操作-hasclass-add-remove-toggle"></a> class 操作 hasClass  add remove toggle</h3><ul><li>hasClass( ‘className’ ) :</li><li>addClass(’ ') :</li><li>removeClass( ’ ’ ) :</li><li>toggleClass(’ ',trigger) : ClassName 触发器</li></ul><h3 id="html-操作-text-html-val"><a class="markdownIt-Anchor" href="#html-操作-text-html-val"></a> html 操作 text   html  val</h3><h3 id="html-属性操作-attr-removeattr-data-removedata"><a class="markdownIt-Anchor" href="#html-属性操作-attr-removeattr-data-removedata"></a> html 属性操作  attr   removeAttr  <abbr title="传递event.data给事件处理函数*">data</abbr>  removeData</h3><h2 id="文档处理"><a class="markdownIt-Anchor" href="#文档处理"></a> 文档处理</h2><h3 id="append-insert-replace-remove-clone"><a class="markdownIt-Anchor" href="#append-insert-replace-remove-clone"></a> append  insert replace remove clone</h3><h2 id="盒模型"><a class="markdownIt-Anchor" href="#盒模型"></a> 盒模型</h2><h3 id="width-inner-outer-"><a class="markdownIt-Anchor" href="#width-inner-outer-"></a> width  inner-  outer-</h3><ul><li>width() : 内容宽（border-box模式也一样）</li><li>innerWidth() : 内容宽+padding宽</li><li>outerWidth() :  内容宽+padding宽+border宽</li><li>outerWidth(true) :  内容宽+padding宽+border宽+margin宽</li></ul><h3 id="offset-position-scroll"><a class="markdownIt-Anchor" href="#offset-position-scroll"></a> offset   position  scroll</h3><ul><li>offset() : 相对于文档位置的偏移量 一个对象  包含top left  可设置</li><li>position() : 相对于定位父级的偏移量 一个对象  包含top left  只读</li><li>scrollTop()  scrollLeft() :  设置/获取滚动条位置</li></ul><h2 id="过渡和动画"><a class="markdownIt-Anchor" href="#过渡和动画"></a> 过渡和动画</h2><h3 id="显示隐藏show-hide"><a class="markdownIt-Anchor" href="#显示隐藏show-hide"></a> 显示隐藏show   hide</h3><p>show/hide ([speed],[easing],[fn])  :   过渡属性有  宽  高 和透明度</p><ul><li>speed : 动画时长的毫秒值</li><li>ease : 用来指定切换效果  默认 swing(加速)   可以是 linear</li><li>fn  回调函数： 动画结束后执行的函数</li></ul><h3 id="淡入淡出fade"><a class="markdownIt-Anchor" href="#淡入淡出fade"></a> 淡入淡出fade</h3><ul><li>fadeIn/fadeOut ([speed],[easing],[fn])  : 透明度  +  display  （会影响文档流哦）</li><li>fadeToggle  ([speed],[easing],[fn]) :  淡入淡出触发器</li><li>fadeTo(speed,opacity,fn) : 过渡到指定透明度</li></ul><h3 id="展开收缩-slide"><a class="markdownIt-Anchor" href="#展开收缩-slide"></a> 展开收缩  slide</h3><ul><li>slideDown / slideUp ([speed],[easing],[fn])  :  下拉效果  height + display</li><li>slideToggle  ([speed],[easing],[fn])  :  触发器</li></ul><h3 id="动画-animate"><a class="markdownIt-Anchor" href="#动画-animate"></a> 动画  animate</h3><ul><li><p>animate(styles,[speed],[easing],[callback])</p></li><li><p>animate(styles,options) :</p><p>styles: 样式值  可以用 ’+=50px‘ 设置相对动画</p><p>options 可能取值 :</p><ul><li>speed</li><li>easing</li><li>callback</li><li>step</li><li>queue</li><li>specialEasing</li></ul></li></ul><h3 id="动画停止-stop-finish"><a class="markdownIt-Anchor" href="#动画停止-stop-finish"></a> 动画停止  stop finish</h3><ul><li><p>stop ([stopAll],[goToEnd])</p><p>清除所有的JQ效果函数，包括淡入淡出，滑动等。</p><p>通常可用于避免动画过程跟不上动作的bug</p><ul><li>stopAll  参数规定是否应该清除动画队列。默认是 false ，即仅停止活动的<br>动画，允许任何排入队列的动画向后执行。</li><li>goToEnd  参数规定是否立即完成当前动画。默认是 false</li></ul><p>因此，默认地， stop() 会清除在被选元素上指定的当前动画</p></li><li><p>finish() :  相当于  stop(true,true) : 清空当前动画队列，并且目前的动画跳到其最终值</p></li><li><p>​</p></li></ul><h3 id="动画延迟-delay-queue-dequeue"><a class="markdownIt-Anchor" href="#动画延迟-delay-queue-dequeue"></a> 动画延迟  delay  queue  dequeue</h3><ul><li><p>queue ([queueName]) : 强行队列</p></li><li><p>dequeue () : 强行加入队列的任务需要主动退出，否则队列被占用</p></li><li><p>delay(duration) : 延迟</p><blockquote><p><strong>delay  只延迟动画队列</strong></p></blockquote></li></ul><h2 id="jq-事件"><a class="markdownIt-Anchor" href="#jq-事件"></a> JQ 事件</h2><h3 id="原生js事件去掉-on"><a class="markdownIt-Anchor" href="#原生js事件去掉-on"></a> 原生JS事件去掉 on</h3><h3 id="hover-滑入滑出事件"><a class="markdownIt-Anchor" href="#hover-滑入滑出事件"></a> hover() 滑入滑出事件</h3><ul><li>hover(fn1,fn2)</li></ul><h3 id="事件绑定和代理解除-on-off-one-trigger"><a class="markdownIt-Anchor" href="#事件绑定和代理解除-on-off-one-trigger"></a> 事件绑定和代理，解除  on  off  one trigger</h3><ul><li><p>on( events,[selector],[<abbr title="传递event.data给事件处理函数*">data</abbr>],callback )</p><ul><li><blockquote><p><strong>绑定单个事件</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.box'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>绑定多个事件</strong></p></li></ul>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.box'</span>).on(&#123;</span><br><span class="line"><span class="string">'click'</span>：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="string">'hover'</span>：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>事件代理、委托</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).on(<span class="string">'click'</span>,<span class="string">'li'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'ok'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">'#div1'</span>).append($(<span class="string">'&lt;li&gt;new&lt;/li&gt;'</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>off ()</code>  :  取消所有事件，   <code>off('click')</code> : 取消单个事件</p></li><li><p><code>one (event,fn)</code> : 绑定一次性事件处理函数，相当于在事件处理函数取消事件</p></li><li><p><code>trigger (type,[data])</code> : 主动触发，可以用于自定义事件</p><ul><li>type :  事件类型</li><li><abbr title="传递event.data给事件处理函数*">data</abbr> : 数组形式传递给事件函数参数</li></ul></li><li><p><code>triggerHandler(type,[data])</code>  :  和trigger 一样，但是它有以下三个优势</p><ul><li>能阻止浏览器默认事件</li><li>只触发JQ对象集合中第一个元素的事件处理函数</li><li>可以有自己的返回值</li></ul></li></ul><h3 id="事件对象-event"><a class="markdownIt-Anchor" href="#事件对象-event"></a> 事件对象 event</h3><ul><li>event.<abbr title="传递event.data给事件处理函数*">data</abbr> : 给事件函数传递数据</li><li>event.target : 事件源</li><li>event.type : 事件类型</li><li>event.pageX : 鼠标相对于文档左边缘的位置</li><li>event.pageY : 鼠标相对于文档上边缘的位置</li><li>event.which : 针对键盘和鼠标事件，用这个属性确定你到底按那个按钮</li><li>event.preventDefault() : 阻止默认事件</li><li>event.stopPropagation() :  阻止冒泡事件</li></ul><h2 id="jq-ajax"><a class="markdownIt-Anchor" href="#jq-ajax"></a> JQ Ajax</h2><h3 id="加载-load"><a class="markdownIt-Anchor" href="#加载-load"></a> 加载  load</h3><p>load( url,<abbr title="传递event.data给事件处理函数*">data</abbr>,function(response,status,xhr) )</p><blockquote><p>**load 方法通过 AJAX 请求从服务器加载数据，并把返回的数据放置到指定的元素中。**默认get请求</p></blockquote><p>function(response,status,xhr) 参数如下</p><ul><li>response ­ 包含来自请求的结果数据</li><li>status ­ 包含请求的状态（”success”, “notmodified”, “error”, “timeout” 或 “parsererror”）</li><li>xhr ­ 包含 XMLHttpRequest 对象</li></ul><p>load 方法强大之处在于，它不仅可以请求后台服务器，还可以请求后台文件来加载</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).load(<span class="string">'test.txt'</span>);  <span class="comment">// 请求txt文件</span></span><br><span class="line">$(<span class="string">"#result"</span>).load(<span class="string">"ajax/test.html"</span>);  <span class="comment">// 请求html页面</span></span><br><span class="line">$(<span class="string">'#box'</span>).load(<span class="string">'test.html #wrap'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'ok'</span>)&#125;);<span class="comment">// 碎片化加载</span></span><br><span class="line">$(<span class="string">'#box'</span>).load(<span class="string">'test.php'</span>,&#123;<span class="attr">age</span>:<span class="number">25</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'ok'</span>)&#125;); <span class="comment">// post请求</span></span><br></pre></td></tr></table></figure><h3 id="请求-ajax"><a class="markdownIt-Anchor" href="#请求-ajax"></a> 请求 ajax</h3><blockquote><p><strong>ajax是工具函数，直接用$调用，传递参数是json对象，通常有以下几个参数</strong></p></blockquote><ul><li>type ： 请求方式   值为   POST  or  GET   默认  GET</li><li>url  ：  请求url</li><li>async ： 是否异步  默认 true</li><li><abbr title="传递event.data给事件处理函数*">data</abbr> :  传递的数据   通常为json对象</li><li>dataType : 预期服务器返回的数据格式类型，可以有以下几种（但得看后台是否支持）<ul><li>xml  :  返回xml 文档</li><li>html :  返回纯文本html 信息</li><li>script : 返回纯文本的js代码</li><li>json : 返回JSON数据</li><li>jsonp :  使用jsonp 跨域去拉取回调函数并调用，注意所有post请求都将变为get</li><li>text : 纯文本字符串</li></ul></li><li>cache : 是否缓存，默认为 true  除非dataType 值为script 或 jsonp</li><li>success (response,status,jqXHR) : 请求成功的回调函数</li><li>error :  function(response,status,errorMessage) : 请求出错的回调函数</li><li>contentType :  内容编码类型  默认为 “application/x­www­form­urlencoded&quot;</li><li>jsonp : 重写回调函数的名字</li><li>jsonpCallback : 为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名</li><li>context : 这个对象用于设置Ajax相关回调函数的上下文。也就是说，让回调函数内this指向这个对象（如果不设定这个参数，那么this就指向调用本次AJAX请求时传递的options<br>参数）。</li></ul><h2 id="jq-工具和扩展"><a class="markdownIt-Anchor" href="#jq-工具和扩展"></a> JQ  工具和扩展</h2><blockquote><p>JQ的工具方法  同样可以给原生JS对象用！！</p></blockquote><h3 id="通用工具函数-type-each-proxy-noconflict"><a class="markdownIt-Anchor" href="#通用工具函数-type-each-proxy-noconflict"></a> 通用工具函数  type  each  proxy   noConflict</h3><p>jQuery.type ()  判断类型</p><p>jQuery.each(obj,[callback]) : 遍历各样集合或JSON</p><p>jQuery.proxy( function, context ) : 改变函数的this 指向</p><p>noConflict() :  将$变量释放  返回另一个别名（避免插件之间的冲突）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jq = $.noConflict();</span><br></pre></td></tr></table></figure><h3 id="数据交互工具函数-get-post-getjson"><a class="markdownIt-Anchor" href="#数据交互工具函数-get-post-getjson"></a> 数据交互工具函数  get  post  getJSON</h3><blockquote><p><strong>以下三个函数相当于简化的ajax</strong></p></blockquote><ul><li>get(url,<abbr title="传递event.data给事件处理函数*">data</abbr>,success(response,status,xhr),dataType) :  get 请求</li><li>jQuery.post(url,<abbr title="传递event.data给事件处理函数*">data</abbr>,success(<abbr title="传递event.data给事件处理函数*">data</abbr>, textStatus, jqXHR),dataType)  post 请求</li><li>jQuery.getJSON(url,<abbr title="传递event.data给事件处理函数*">data</abbr>,success(<abbr title="传递event.data给事件处理函数*">data</abbr>,status,xhr))   用get 请求JSON数据</li></ul><h3 id="继承与扩展"><a class="markdownIt-Anchor" href="#继承与扩展"></a> 继承与扩展</h3><ul><li>jQuery.extend( [deep], target, object1, [objectN] )  :  让target 对象继承自obj</li></ul><p>其中可以有deep标明深度继承，默认为false : 如果父级对象有引用类型的数据，那么子继承对象将共享该数据段，如果设定为true,递归合并，生成新的副本</p><ul><li>jQuery.extend( object ) ： 工具函数的扩展</li><li>jQuery.fn.extend (obj ) :  对象的方法扩展</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jquery&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jquery&quot;&gt;&lt;/a&gt; JQuery&lt;/h1&gt;
&lt;h2 id=&quot;jquery-设计精髓&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jquery
      
    
    </summary>
    
      <category term="web开发" scheme="http://www.it120cc.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端开发" scheme="http://www.it120cc.com/categories/web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="jquery" scheme="http://www.it120cc.com/categories/web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/jquery/"/>
    
    
      <category term="jquery" scheme="http://www.it120cc.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>markdown简介</title>
    <link href="http://www.it120cc.com/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/markdown/markdown-start.html"/>
    <id>http://www.it120cc.com/构建工具/markdown/markdown-start.html</id>
    <published>2018-01-19T10:46:15.000Z</published>
    <updated>2019-06-19T00:40:54.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="markdown简介"><a class="markdownIt-Anchor" href="#markdown简介"></a> markdown简介</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面.  ——<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>双回车退出上级样式</p><p><font style="font-size: 16px; color: red;"> 自定义样式要在HTML中体现 </font></p><h3 id="强调格式"><a class="markdownIt-Anchor" href="#强调格式"></a> 强调格式</h3><p>创建<strong>粗体</strong> 或<em>斜体</em> 或脚注<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>,param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Util = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  判断是否是IE</span></span><br><span class="line"><span class="comment">     *  @return &#123;boolean&#125; .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getIsIE: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line">        <span class="keyword">var</span> isOpera = <span class="regexp">/opera/</span>.test(ua);</span><br><span class="line">        <span class="keyword">var</span> isie = <span class="regexp">/msie/</span>.test(ua);</span><br><span class="line">        <span class="keyword">return</span> !isOpera &amp;&amp; isie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="latex公式可以吗"><a class="markdownIt-Anchor" href="#latex公式可以吗"></a> Latex公式可以吗？</h3><p>块级公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276389em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.590389em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.913389em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span></span></span><span style="top:-2.873389em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12661100000000003em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>行内公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mspace width="1em"><mi mathvariant="normal">∀</mi><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mspace></mrow><annotation encoding="application/x-tex">\Gamma(n)=(n-1)!\quad\forall n\in\mathbb N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">∀</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">N</span></span></span></span></p><h3 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h3><table><thead><tr><th style="text-align:center">item</th><th style="text-align:center">value</th><th style="text-align:center">Qty</th></tr></thead><tbody><tr><td style="text-align:center">Computer</td><td style="text-align:center">1600</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">phone</td><td style="text-align:center">12</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">pipe</td><td style="text-align:center">1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="流程图和时序图"><a class="markdownIt-Anchor" href="#流程图和时序图"></a> 流程图和时序图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: yes or no?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Alice-&gt;Bob: Hello Bob,how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="甘特图"><a class="markdownIt-Anchor" href="#甘特图"></a> 甘特图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">client1--&gt;|read / write|SVN((SVN server)) </span><br><span class="line">client2--&gt;|read only|SVN </span><br><span class="line">client3(...)--&gt;SVN</span><br><span class="line">SVN--&gt;|store the data|SD(sharedrive)</span><br></pre></td></tr></table></figure><p>###复选框和列表</p><p>使用<code>-[]</code>和 <code>-[x]</code>语法可以创建复选框，实现todo-list等功能例如：</p><ul><li><p>[ ] 复选框</p></li><li><p>[ ] 复选框</p></li></ul><ol><li>有序列表1</li><li>有序列表2</li></ol><ul><li>无序列表</li><li>无序列表</li></ul><h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=4189594639,2182906807&amp;fm=58" alt="图片描述"></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;markdown简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#markdown简介&quot;&gt;&lt;/a&gt; markdown简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本
      
    
    </summary>
    
      <category term="构建工具" scheme="http://www.it120cc.com/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="markdown" scheme="http://www.it120cc.com/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/markdown/"/>
    
    
      <category term="markdown" scheme="http://www.it120cc.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>javascript 基础内容详解</title>
    <link href="http://www.it120cc.com/web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/javascript5.html"/>
    <id>http://www.it120cc.com/web开发/前端开发/javascript/javascript5.html</id>
    <published>2017-12-18T12:54:46.000Z</published>
    <updated>2019-06-19T01:01:38.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript-初级"><a class="markdownIt-Anchor" href="#javascript-初级"></a> JavaScript 初级</h1><h2 id="基础通识"><a class="markdownIt-Anchor" href="#基础通识"></a> 基础通识</h2><h3 id="数据类型及其转换"><a class="markdownIt-Anchor" href="#数据类型及其转换"></a> 数据类型及其转换</h3><h4 id="常见数据类型"><a class="markdownIt-Anchor" href="#常见数据类型"></a> 常见数据类型</h4><ol><li><p>boolean:</p></li><li><p>string:</p></li><li><p>number:</p></li><li><p>object:</p></li><li><p>undefine:</p></li><li><p>function:</p><blockquote><p>可以用 <code>typeof</code> 关键字来判断变量的数据类型</p></blockquote><blockquote><p>null  NaN undefined 0 和 空字符串 “” 的区别在这</p></blockquote></li></ol><h4 id="数据类型显示转换"><a class="markdownIt-Anchor" href="#数据类型显示转换"></a> 数据类型显示转换</h4><ul><li>字符串 转数字:  <code>Number(str);</code>  从第一位不是空格的位置开始，可以允许负号、小数点、前导0以及十六进制标识符<code>0x</code>，空字符串转为0，遇到不能识别字符，返回<code>NaN</code></li><li><code>Number(Boolen);</code>  布尔值转数值，true 转为1，false转为0</li><li>字符串 转整数: <code>parseInt(str,base)</code>从第一位不是空格位置到不能识别的字符(不包括小数点)，无法转换返回<code>NaN</code></li><li>字符串 转小数: <code>parseFloat(str)</code>从第一位不是空格位置到不能识别的字符，无法转换返回<code>NaN</code></li></ul><h4 id="数据类型的隐式转换"><a class="markdownIt-Anchor" href="#数据类型的隐式转换"></a> 数据类型的隐式转换</h4><ul><li><p>一元操作符触发的隐式类型转换：</p></li><li><p>++  –  自增、自减操作均能隐式调用Number函数</p></li><li><p>注意，自增自减操作不能作用于常量，会报错，比如 <code>'a' ++</code>   是错误的</p></li><li><p>加性操作符触发的隐式类型转换：</p><ul><li>加法操作符作用在数值相加和字符串拼接上，字符串优先（还是从左到右运算），有字符串则先转为字符串，没有字符串就通通转为数值运算。</li><li>减法操作符只作用在数值上！不是数值类型的都要转数值类型</li><li>加法操作符作为<code>正号</code>，减法操作符作为 <code>负号</code>会触发调用Number</li></ul></li><li><p>乘性操作符触发的隐式类型转换：</p><ul><li>乘法、除法、取模操作符，均只作用在数值上！不是数值类型的都要转数值类型</li></ul></li><li><p>关系操作符触发的隐式类型转换：</p><ul><li>只需要搞清楚的本质是：关系操作符只作用在数值上！</li><li>特殊的在于，大于小于操作符合加性操作符一样，能作用在字符串比较上，但是还是<code>数值比较优先</code></li><li>undefined   null  <code>NaN</code>在比较中不能被转换，但是undefined == null，<code>NaN != NaN</code>   （这类关系本质可以理解为对象的相等比较）</li><li>全等比较用得最多了，就不用多说了吧，它不会触发隐式类型转换</li></ul><p>​++  – *  /  &amp;   正号+  负号-   均能隐式调用 Number</p></li></ul><p>据此我们来解释一下这两个现象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>&lt;<span class="number">2</span>&lt;<span class="number">3</span>, <span class="number">3</span>&lt;<span class="number">2</span>&lt;<span class="number">1</span>];  <span class="comment">// [true, true]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">"true"</span> == <span class="literal">true</span>, <span class="string">"true"</span> == <span class="literal">false</span>]; <span class="comment">// [false, false]</span></span><br></pre></td></tr></table></figure><h3 id="运算符-条件和循环"><a class="markdownIt-Anchor" href="#运算符-条件和循环"></a> 运算符、条件和循环</h3><ol><li>利用逻辑运算符的短路特性完成判断</li><li>利用条件操作符简化判断</li><li>逗号表达式***</li><li>switch case 分支判断</li></ol><blockquote><p>所有这些都只为简化  if  else  语句</p></blockquote><h2 id="函数及其高级"><a class="markdownIt-Anchor" href="#函数及其高级"></a> 函数及其高级</h2><h4 id="javascript-原生语法和-c-相似"><a class="markdownIt-Anchor" href="#javascript-原生语法和-c-相似"></a> JavaScript 原生语法和 C 相似</h4><blockquote><p>函数的本质是对象 Object  函数名实质就是函数指针 （C类似）</p></blockquote><ol><li><p>变量复制操作均为值拷贝，只是要把javaScript的Object 理解为指针</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(), obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log (obj2.name); <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>函数传参只有按值传递，只是传递Object传的是个指针</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">"Nicho"</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName (Person);</span><br><span class="line"><span class="built_in">console</span>.log(Person.name) <span class="comment">// "Nicho"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>只有全局作用域和局部作用域（作用域链）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">anotherColor = color;</span><br><span class="line">color = tempColor;</span><br><span class="line"><span class="comment">// 这里可以访问color、anotherColor 和tempColor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里可以访问color 和anotherColor，但不能访问tempColor</span></span><br><span class="line">swapColors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>作用域链表：</p><table><thead><tr><th style="text-align:left">window</th><th>changeColor</th><th>swapColors</th></tr></thead><tbody><tr><td style="text-align:left">color</td><td>color</td><td>color</td></tr><tr><td style="text-align:left">changeColor</td><td>anotherColor</td><td>anthorColor</td></tr><tr><td style="text-align:left"></td><td>swapColors</td><td>tempColor</td></tr></tbody></table><h4 id="函数声明和函数表达式"><a class="markdownIt-Anchor" href="#函数声明和函数表达式"></a> 函数声明和函数表达式</h4><blockquote><p>函数定义的方式有两种，一种是函数声明，另一种是函数表达式，这两种看似一样，实际有本质区别！</p></blockquote><p><strong>函数声明语句是会提前的</strong>  （function declaration hoisting）</p><p>函数声明的语法结构：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">arg1,arg2,...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数表达式的语法结构： <strong>（匿名函数被赋值或调用了）</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">arg1,arg2,..</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果函数声明和函数表达式一起来会怎样？   那就是函数表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fn();  提示fn 未定义</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;<span class="comment">/**()**/</span>; <span class="comment">// 此处加括号执行函数表达式 b 已经声明只是未定义</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// b();正常</span></span><br></pre></td></tr></table></figure><blockquote><p>函数名和变量名同名，函数名优先作声明</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn); <span class="comment">// function </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn); <span class="comment">// number</span></span><br></pre></td></tr></table></figure><h4 id="js-解析顺序"><a class="markdownIt-Anchor" href="#js-解析顺序"></a> js 解析顺序</h4><p>千万不要以为js和其他语言一样是从头到尾一条条语句顺序执行的，在js解释器<code>V8引擎</code>对js解释时分为两个阶段，首先是编译期，编译期首先是对代码进行静态分析，找出声明的变量，函数，并检查语法是否符合规范，这就是我们常说的js的前置声明特性。</p><p>所以使用变量必须要先声明，没有声明就是不能识别的标识符，会报错（不是undefined），这个异常是任何语言都有的，只不过说前置声明特性是<code>js</code>特有的</p><p>编译期完成后再到运行期，在运行期间，执行的语句就是前置声明后的顺序了。</p><p>所以上述的例子，通过这个特性就不难理解了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn()()</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(a)        <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(a)<span class="comment">// function(a) &#123;alert(a)&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(a) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="函数内部属性"><a class="markdownIt-Anchor" href="#函数内部属性"></a> 函数内部属性</h3><ol><li><p>argument 参数数组属性</p><blockquote><p>用于保存参数数组的对象，其中还有一个属性callee,含义为该函数本身，用于函数内部自身调用(递归),callee下面还有一个caller 属性,含义为该函数的调用者,这两个属性的使用可以降低函数名被修改后的耦合度，在严格模式下会报错</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 例子： 用argument 属性递归</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>this 指针属性</p></li></ol><blockquote><p>指向调用函数的对象本身</p></blockquote><blockquote><p>在严格模式下，未指定环境对象而调用函数，则this 值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。</p></blockquote><h3 id="函数属性和方法"><a class="markdownIt-Anchor" href="#函数属性和方法"></a> 函数属性和方法</h3><ol><li>length : 参数形参的长度</li><li>call   apply 函数</li><li>bind 函数</li></ol><h3 id="函数闭包"><a class="markdownIt-Anchor" href="#函数闭包"></a> 函数闭包</h3><h4 id="闭包现象"><a class="markdownIt-Anchor" href="#闭包现象"></a> 闭包现象</h4><p>简单来说，能出现闭包的表面现象有两个特征：</p><ol><li>函数内部嵌套函数</li><li>内部函数使用父函数的 变量或者参数</li></ol><p>那么满足上述两个条件的内部函数就可以称作闭包，闭包的特性包括两个方面：</p><ul><li>闭包使用的父函数的变量或者参数，会被永久保存！</li><li>生命周期跟全局变量一样，会常驻内存，程序关闭才会回收</li><li>上一条是给新手理解的，其实它的生命周期和调用者引用它的变量一致</li></ul><p>当然，上述说到的只是表面现象，但是这个特性和我们之前学的函数的栈执行顺序明显相冲突了，要说他具体是怎么实现的，就不得不说一个函数执行上下文概念</p><h4 id="函数执行上下文"><a class="markdownIt-Anchor" href="#函数执行上下文"></a> 函数执行上下文</h4><blockquote><p>前置声明：其实了解完这部分内容，目的只是为了打破一些人“代入式”思维而转换成“跳转式”思维就可以了</p></blockquote><p>所谓的“代入式”思维和“跳转式”思维什么意思呢？其实这只是我抽象出来的名词，要想解释只需一个实例就是最直接了当明白了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 如果是“跳转式”思维，就会跳到这里去执行，这时候跳出来后，就自然认为x是10了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    f();<span class="comment">// 如果是“代入式”思维，就会把f的函数体 console.log(x)带入这一行执行，这时会认为是20了。</span></span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">show(f);</span><br></pre></td></tr></table></figure><p>如果你是前一种，接下来的内容就值得你重视了，如果你是后一种你更要重视了，因为你会比前一种更容易忽略容易忘。</p><p>要想知道函数上下文，又得知道函数执行时的活动区域，在函数执行时需要维护函数参数，局部变量，返回值，以及上一次执行的栈指针等变量，这些变量构成的就是活动区域，但是这还不是上下文，所谓上下文就是创建函数活动区域的环境，是不是和之前说过的函数的作用域链有点熟悉，事实就是如此，函数执行时它的作用域链是怎么来的呢？当函数创建时（声明）时会在其内部保存一个<code>[[Scope]]</code>内部属性，这就是函数上下文…的一部分…（别得意~还有很多值得你探索的呢<code>[[construct]]</code> <code>[[call]]</code>你又可知道？）别灰心，能把函数上下文理解到这里就够了，还不理解？别灰心，我就说再简单点，<strong>函数声明的时候它能访问的作用域链就已经确定了</strong>，那么在函数执行的时候，只需要把已经准备好的作用域链 <code>[[scope]]</code>引用到函数的活动区域即可。</p><p>一番文字介绍完了，可能不能给你达到茅塞顿开的效果，但是至少迷雾驱散了吧~~那么在今后分析js执行时更应该用代入式的还是跳转式呢？</p><p>到这里我又要来一番文字了，来介绍一下闭包是怎么形成的吧，为什么它可以破坏我们常规认识的栈执行顺序呢？</p><blockquote><p>注意了，如果担心看完下面的文字后和上面搞混，回到代入式思维去的话，就建议别看了，哈哈~~~</p></blockquote><p>还是一样，先给个实例，在抽象的东西出现之前</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// 闭包函数的函数上下文已经创建</span></span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = fn(<span class="number">1</span>); <span class="comment">// 闭包函数已经被外部引用，返回给a，它的生命周期已经和变量a一致，在内存中不被销毁</span></span><br><span class="line">    alert(a());<span class="comment">// 2</span></span><br><span class="line">    alert(a());<span class="comment">// 3</span></span><br><span class="line">    &#125;)();<span class="comment">// 变量a销毁，闭包函数的活动区域也销毁</span></span><br><span class="line"><span class="keyword">var</span> a = fn(<span class="number">1</span>);  <span class="comment">// 闭包函数再次被外部引用，返回给a</span></span><br><span class="line">    alert(a());<span class="comment">// 2</span></span><br><span class="line">    alert(a());<span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 全局执行结束，闭包函数活动区域销毁</span></span><br></pre></td></tr></table></figure><p>好了，接下来我要偷换概念了我把上面所说的活动区域换成<code>执行上下文</code>，咬文嚼字吧，注意区别，函数上下文和执行上下文哈！</p><p>所以一切了然了，我们常认识的函数的栈执行顺序这个认识没有被闭包特性破坏，因为这个认识销毁的是函数的执行上下文！而闭包之所以提升它外部变量的生命周期，是因为它维护的是函数上下文，当闭包函数被外部引用的时候，闭包函数的上下文的生命周期已经和这个调用它的变量一致了。所以表面上你会认为把闭包函数拿出来再外部执行了，实际上不是！只是生命周期一致罢了，不代表函数上下文的内容一致。当这个引用调用函数并执行完成后，执行上下文自然被销毁，但是这并不影响函数上下文的存在，当这个引用对象销毁了，那么闭包函数的上下文自然被销毁了。</p><p>可以理解这种情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">name : <span class="string">"My Object"</span>,</span><br><span class="line">getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());<span class="comment">// "The Window" 主要是理解调用者是谁，可以认为执行object.getNameFunc()被window对象接收了。</span></span><br></pre></td></tr></table></figure><h4 id="闭包应用"><a class="markdownIt-Anchor" href="#闭包应用"></a> 闭包应用</h4><ol><li><p>分割作用域</p><p>分割作用域的目的就在于防止变量的全局污染，由于在js中没有块级作用域，唯一能分割的办法就是创建立即执行的匿名闭包函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; div.length; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    div[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>模块封装</p><p>模块封装的目就是要让变量私有化，暴露接口给外部操作，这其实就是一般面向对象的编程语言中类的概念了，是的在js中也很常用闭包函数来做模块封装，在我们常使用的插件jquery、zpeto等都体现了这个特性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> common = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x,y,_x,_y;<span class="comment">// 私有化的变量</span></span><br><span class="line">  <span class="comment">// 初始化处理</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="comment">// 公共访问的接口</span></span><br><span class="line">    setX: <span class="function"><span class="keyword">function</span>(<span class="params">vx</span>) </span>&#123;</span><br><span class="line">      x = vx;</span><br><span class="line">    &#125;,</span><br><span class="line">    setY: <span class="function"><span class="keyword">function</span>(<span class="params">vy</span>) </span>&#123;</span><br><span class="line">      y = vy;</span><br><span class="line">    &#125;,</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">    getY: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.common = common;</span><br></pre></td></tr></table></figure><p>当然，这个common只能算是一个单例对象，它还不具备有面向对象的特性，但是从这里至少可以看到封装的体现了。在真正的插件封装，还是需要使用js面向对象的特性的。</p></li></ol><h4 id="闭包问题"><a class="markdownIt-Anchor" href="#闭包问题"></a> 闭包问题</h4><ul><li>大量引用闭包保存了大量的函数上下文（作用域）比一般函数占用更多内存</li><li>如果不注意释放引用，没有合理设计闭包，造成循环引用会导致内存泄露（永远释放不了的内存）。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 闭包函数在这里就被引用了</span></span><br><span class="line">  alert(element.id);<span class="comment">// 引用外部变量，element不会被销毁</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用自带引用类型"><a class="markdownIt-Anchor" href="#常用自带引用类型"></a> 常用自带引用类型</h2><h3 id="基本类型的包装-基本包装类型"><a class="markdownIt-Anchor" href="#基本类型的包装-基本包装类型"></a> 基本类型的包装 -&gt; 基本包装类型</h3><p>在js 中基本类型的包装类主要有三种：<code>Boolean</code> <code>Number</code> 和 <code>string</code> 他们都有其对应的字面量。而对于基本类型的包装类，需要严格注意的是它的本质，这些包装类型都已经成了Object，已经第一节所说的那些基本类型了！</p><h3 id="object"><a class="markdownIt-Anchor" href="#object"></a> object</h3><h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> json</h3><h3 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h3><h3 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h3><h3 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h3><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><h1 id="javascript-用户响应及特效基础"><a class="markdownIt-Anchor" href="#javascript-用户响应及特效基础"></a> JavaScript 用户响应及特效基础</h1><h2 id="js-dom"><a class="markdownIt-Anchor" href="#js-dom"></a> JS DOM</h2><h3 id="dom-节点属性"><a class="markdownIt-Anchor" href="#dom-节点属性"></a> dom 节点属性</h3><p>nodeType  节点类型 常用的值如下</p><p>Node.ELEMENT_NODE(1);元素节点</p><p>Node.ATTRIBUTE_NODE(2);属性节点</p><p>Node.TEXT_NODE(3);文本节点</p><p>Node.DOCUMENT_NODE(9);文档节点</p><blockquote><p>注意 在IE9一下并没有定义这些常量，因此为了兼容性通常直接写数值即可</p></blockquote><p>nodeName 和 nodeValue</p><p>这两个都是获取节点内容，其中nodeName 是针对元素节点有效，nodeValue是针对文本节点有效</p><blockquote><p>因此使用这两个前一般都增加nodeType判断</p></blockquote><h3 id="节点关系属性"><a class="markdownIt-Anchor" href="#节点关系属性"></a> 节点关系属性</h3><ul><li>parentNode 保存父元素节点</li><li>offsetParent 保存定位父元素节点  最高到body上</li><li>children  保存子元素节点</li></ul><blockquote><p>注意： 得到的子元素节点是nodeList类型，可以使用方括号[]或item(i)访问，但不能像数组一样操作，虽然可以转换为Array，但是在IE9以下并不支持这种转换，因为nodeList是基于COM对象实现的，不是Jscript.</p></blockquote><p>后面几个将不常用，而且部分有兼容性问题</p><ul><li><p>childNodes 得到所有子节点</p><p>但在IE9以下只得到子元素节点</p></li><li><p>firstChild  得到第一个子节点</p><p>但在IE9以下只得到第一个子元素节点</p></li><li><p>lastChild   得到最后一个子节点</p><p>但在IE9以下只得到最后一个子元素节点</p></li><li><p>firstElementChild   得到第一个元素节点</p><p>不兼容IE8</p></li><li><p>lastElementChild  得到最后一个元素节点</p><p>不兼容IE8</p></li><li><p>nextSibling / previousSibling 得到下一个/前一个兄弟节点</p><p>这个属性在不同浏览器就不同啦</p></li><li><p>nextElementSibling / previousElementSibling 得到下一个/前一个兄弟元素节点</p><p>这个就不支持IE9以下啦</p></li></ul><h3 id="节点操作"><a class="markdownIt-Anchor" href="#节点操作"></a> 节点操作</h3><ul><li>createElement()</li></ul><p>新建元素节点,需要接受一个参数,参数就是需要新建的标签</p><ul><li><p>createTextNode()     新建文本节点</p></li><li><p>document.createDocumentFragment()  创建文档碎片，用以保存批量已经创建的节点统一插入HTML中渲染</p></li><li><p>父级.appendChild(子节点)    追加一个节点</p></li><li><p>父级.insertBefore(子节点, 指定的子节点)    添加到指定的节点前面</p></li><li><p>父级.replaceChild(新节点，子节点)  替换指定的节点</p></li><li><p>父级.removeChild(需要删除的节点)</p></li><li><p>节点.cloneNode (true)  深度克隆节点及其子节点，注意不克隆元素在JS中定义的属性</p></li></ul><h3 id="获取元素"><a class="markdownIt-Anchor" href="#获取元素"></a> 获取元素</h3><ul><li>获取id 标识的元素：  document.getElementById()</li></ul><p>以下方式不能兼容到IE8 以下</p><ul><li><p>获取类名class标识的元素  元素.getElementsByClassName()</p></li><li><p>用选择器获取元素的第一个   元素.querySelector()</p></li><li><p>用选择器获取所有满足的    元素.querySelectorAll()</p></li><li><p>用标签名获取元素        元素.getElementsByTagName()</p></li></ul><p>注意 含Elements 的返回的是一个HTMLCollect集合这个集合内的元素是动态更新的,而querySelectorAll 返回的是nodeList</p><h3 id="dom-结点属性访问"><a class="markdownIt-Anchor" href="#dom-结点属性访问"></a> dom 结点属性访问</h3><ul><li>点运算访问   元素.合法属性</li><li>函数访问</li></ul><p>获取：元素.getAttribute()</p><p>设置：元素.setAttribute()</p><p>移除：元素.removeAttribute()</p><p>注意:　以上方法只用于获取html自定义属性，不用于获取合法属性，是为了兼容IE7考虑，除此之外，自定义属性应该加上data- 前缀以便通过HTML5合法验证</p><p>和此相关的有attributes 属性得到的属性节点访问(nodeValue)</p><h3 id="样式操作"><a class="markdownIt-Anchor" href="#样式操作"></a> 样式操作</h3><ul><li>通常来说是添加或改变行内样式来实现：</li></ul><p>单一样式 元素.style.属性 obj.style.width = “200px”</p><p>有时要用驼峰命名法来描述属性  paddingLeft</p><p>行内样式 cssText   obj.style.cssText += “width: 200px;”</p><ul><li>复合样式我们要改变类名来实现：</li></ul><p>obj.className+= “active”;</p><ul><li>动态样式追加</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);  </span><br><span class="line">style.innerHTML = <span class="string">'body&#123;color:red&#125; #top:hover&#123;background-color: red;color: white;&#125;'</span>;  </span><br><span class="line"><span class="built_in">document</span>.head.appendChild(style);</span><br></pre></td></tr></table></figure><ul><li>读取内部样式</li></ul><p>window.getComputedStyle(element ).attr</p><p>该方法不支持IE9以下</p><ul><li>读取元素占有宽高和定位距离</li></ul><p>clientWidth    clientHeight:  width + padding</p><p>注意: 该方法常用于获取文档宽高：</p><ul><li>document.body.clientWidth  文档宽高  body宽高</li><li>document.documentElement.clientHeight  可视区域宽高</li><li>window.innerWidth  可视区域的宽高 + 滚动条宽高</li><li>offsetWidth    offsetHeight:  width + padding + border</li><li>scrollWidth    scrollHeight:  content+padding+border</li><li>offsetTop  offsetLeft: 获取元素定位距离</li><li>document.documentElement.scrollTop: 获取滚动高度</li></ul><p>注意 该方法不能兼容旧版的谷歌，最新版的谷歌已经兼容，和火狐IE统一，旧版谷歌的属性:  document.body.scrollTop</p><p>兼容写法:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.scrollTop|| <span class="built_in">document</span>.documentElement.scrollTop )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js-定时器和事件"><a class="markdownIt-Anchor" href="#js-定时器和事件"></a> JS 定时器和事件</h2><h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h2><h3 id="正则表达式的两种创建方法"><a class="markdownIt-Anchor" href="#正则表达式的两种创建方法"></a> 正则表达式的两种创建方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双斜杠法</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象法：一般在需要正则表达式里使用变量时使用</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"/\d+/g"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> ReExp (x);</span><br><span class="line"><span class="comment">/* 常用的正则表达式函数</span></span><br><span class="line"><span class="comment">1. reg.test()  return boolean</span></span><br><span class="line"><span class="comment">2. str.match(reg)  return  一个类数组(有index,input)  在全局匹配下得到的是标准数组</span></span><br><span class="line"><span class="comment">3. str.replace(reg,str) return a new string</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="转义符"><a class="markdownIt-Anchor" href="#转义符"></a> 转义符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/</span> <span class="comment">// \d 匹配数字</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\D/</span> <span class="comment">// \D 匹配非数字字符  和\d相反</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\s/</span> <span class="comment">// \s 匹配空格 和tab \n\r\t等所有产生空格的字符</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\S/</span> <span class="comment">// \S 匹配所有的非空格  和\s相反</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/</span> <span class="comment">// \w 匹配字母、数字和下划线 字符(量身为注册用户名设计)</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\W/</span> <span class="comment">// \W 匹配非 \W</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b/</span> <span class="comment">// \b 匹配单词边界 ： 所有除了\w之外的字符 并包括起始结束</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\B/</span> <span class="comment">// \B 匹配非单词边界   非\w</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/./</span>  <span class="comment">// 匹配所有字符，但不包括****  如果要匹配所有字符 建议[\d\D]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^/</span>  <span class="comment">// 代表起始位置</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/$/</span>  <span class="comment">// 代表结束位置</span></span><br></pre></td></tr></table></figure><h3 id="量词"><a class="markdownIt-Anchor" href="#量词"></a> 量词</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span>  <span class="comment">// + 匹配大于等于1个  数字  相当于&#123;1,&#125;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d?/</span>  <span class="comment">// ? 匹配一个或0个  数字    相当于 &#123;0,1&#125;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d*/</span>  <span class="comment">// * 匹配0或者更多  数字    相当于&#123;0,&#125;</span></span><br></pre></td></tr></table></figure><p>针对于量词  又有<strong>贪婪和惰性</strong>   默认贪婪</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"aaaaaaaabaaa"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a&#123;3,5&#125;b/</span>  <span class="comment">// 如果是贪婪 就匹配5个  如果是惰性 就匹配3个</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a&#123;3,5&#125;?b/</span> <span class="comment">// 惰性的写法  但这样不就  a&#123;3,5&#125;? == a&#123;3&#125;</span></span><br><span class="line"><span class="comment">/**通常来说是贪婪往多的匹配，惰性往少的匹配，但这样解释其实对理解惰性的意义不大</span></span><br><span class="line"><span class="comment">上述例子看出  贪婪和惰性结果是一样的</span></span><br><span class="line"><span class="comment">要正确理解贪婪和惰性，应该要理解正则对量词的匹配原理过程</span></span><br><span class="line"><span class="comment">贪婪过程：  遇到量词，无论多少，先吞掉所有匹配项，再一个个吐回到满足条件为止</span></span><br><span class="line"><span class="comment">惰性过程：  遇到量词，仍然按照顺序匹配，直到满足条件就停止匹配</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">var</span> <span class="string">"a888123999123456"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a\d+123/</span>;  <span class="comment">// 贪婪匹配  先大口吞再吐  结果为a888123999123</span></span><br><span class="line"><span class="keyword">var</span> rerg = <span class="regexp">/a\d+?123/</span>; <span class="comment">// 惰性匹配 一个个吞   结果为a888123</span></span><br></pre></td></tr></table></figure><h3 id="修饰词"><a class="markdownIt-Anchor" href="#修饰词"></a> 修饰词</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/g</span>  <span class="comment">// 全局匹配  匹配成功不会结束</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abcd/i</span>  <span class="comment">//  不区分大小写匹配</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abcd/m</span>  <span class="comment">//  换行匹配 用于$ ^</span></span><br></pre></td></tr></table></figure><h3 id="字符集"><a class="markdownIt-Anchor" href="#字符集"></a> 字符集</h3><h4 id="范围词"><a class="markdownIt-Anchor" href="#范围词"></a> 范围词</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[2,8]/</span>     <span class="comment">// 只匹配 2~8 之间的一个数字 这个大小是根据ASCII表来排序的</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[\u4e00-\u9fa5]/</span>  <span class="comment">// 匹配汉字  \u 代表unicode码</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[ab]/</span>         <span class="comment">// 匹配a或者b之中的一个</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[0-9a-zA-Z]/</span>  <span class="comment">// 匹配所有的数字 字母 （写再长也）只匹配一个 </span></span><br><span class="line"><span class="comment">// 在字符集内  量词无意义</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[^abc]/</span>  <span class="comment">// 范围词内以^开头表示非  非a,b,c以外的所有字符都可以匹配</span></span><br></pre></td></tr></table></figure><h4 id="子集"><a class="markdownIt-Anchor" href="#子集"></a> 子集</h4><blockquote><p><strong>所有量词只能对前面的一个修饰单位作用，这个单位除了一个字符，还可以是一个子集</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(ab)+/</span> <span class="comment">// 匹配&#123;1,&#125;次 ab</span></span><br><span class="line">str.match(reg);  <span class="comment">//  在有子集的情况下，match返回值的类数组里边还包括所有子集</span></span><br></pre></td></tr></table></figure><h4 id="或者"><a class="markdownIt-Anchor" href="#或者"></a> 或者</h4><blockquote><p><strong>默认或者修饰单位是一个整体</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc|d/</span> <span class="comment">// 匹配 abc 或 d</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab(cc|d)/</span> <span class="comment">// 匹配abcc或abd 通常可能要用子集的方式来限制或者的影响范围</span></span><br></pre></td></tr></table></figure><h3 id="使用正则的replace方法"><a class="markdownIt-Anchor" href="#使用正则的replace方法"></a> 使用正则的replace方法</h3><blockquote><p><strong>将匹配到的内容替换，替换的可以是字符串，也可以是个带return 的函数</strong></p><p><strong>replace不改变本身字符</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @param 0: 匹配的内容</span></span><br><span class="line"><span class="comment">  @param[1,n-3]： 依次展现子集，如果没有则忽略</span></span><br><span class="line"><span class="comment">    @param n-2: 出现的序号</span></span><br><span class="line"><span class="comment">    @param n-1:  原字符串本身</span></span><br><span class="line"><span class="comment">    @return string:  替换的字符串</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">val = val.replace(reg,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常用正则"><a class="markdownIt-Anchor" href="#常用正则"></a> 常用正则</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> qq = <span class="regexp">/^[1-9]\d&#123;4,10&#125;$/</span> <span class="comment">// 匹配QQ号</span></span><br><span class="line"><span class="keyword">var</span> tel = <span class="regexp">/^1[3-9]\d&#123;9&#125;$/</span>  <span class="comment">// 匹配手机号</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="regexp">/^[a-z]\w$/i</span>   <span class="comment">// 必须以字母开头  </span></span><br><span class="line"><span class="keyword">var</span> passwd =<span class="regexp">/^\w$/</span>    <span class="comment">// 严格模式的密码：必须是数字字母或特殊符号的两种或以上的组合长度6~16位</span></span><br><span class="line"><span class="keyword">var</span> email =</span><br></pre></td></tr></table></figure><h2 id="js-bom"><a class="markdownIt-Anchor" href="#js-bom"></a> JS BOM</h2><h1 id="javascript-数据交互基础"><a class="markdownIt-Anchor" href="#javascript-数据交互基础"></a> JavaScript 数据交互基础</h1><h2 id="js-cookie"><a class="markdownIt-Anchor" href="#js-cookie"></a> JS  cookie</h2><h2 id="ajax"><a class="markdownIt-Anchor" href="#ajax"></a> Ajax</h2><h2 id="0-jsonp-跨域"><a class="markdownIt-Anchor" href="#0-jsonp-跨域"></a> 0. Jsonp 跨域</h2><h1 id="javascript-框架封装基础"><a class="markdownIt-Anchor" href="#javascript-框架封装基础"></a> JavaScript 框架封装基础</h1><h2 id="js-异常"><a class="markdownIt-Anchor" href="#js-异常"></a> JS 异常</h2><h2 id="js-oop"><a class="markdownIt-Anchor" href="#js-oop"></a> JS OOP</h2><h3 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h3><ol><li><p>用原生JS充当<strong>构造函数</strong>创建对象方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span> (<span class="params">name,age,sex</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sex = sex;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = person();</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>new</code> 关键字的作用</p><blockquote><p>隐式在函数内部创建对象</p><p>将this指向该对象</p><p>最后返回该对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  <span class="keyword">this</span>.sayName= <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person();</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="原型和原型链"><a class="markdownIt-Anchor" href="#原型和原型链"></a> 原型和原型链</h3><blockquote><p>之前用new创建对象的方法看上去没什么问题，每创建一个new对象，就能创建独立的变量空间，不同对象之间同名变量互不干扰。</p><blockquote><p>但是，对于函数<code>sayName</code> 来说，尽管在不同对象之间，但都是一样的。但是仍然需要给每个对象生成一个相同的空间保存该函数。</p></blockquote></blockquote><p>因此，我们就有了一个专门用于共享数据空间的东西 —— 原型</p><p>什么是原型，在弄懂这个之前，先记住，所有函数都有一个原型(prototype)，</p><p>然后原型本质上就是一个对象（指针）指向一块可变得内存空间。</p><p>那么也就是说，任一个函数通过<code>prototype</code>属性都能访问到该共享空间</p><p>那么，通过构造函数<code>new</code>出来的对象是怎么得到这块空间呢？</p><p>其实<code>new</code>操作会将构造函数的<code>prototype</code>的值赋给<code>new</code>出来的对象下的<code>__proto__</code>属性下，也就是说构造函数的<code>prototype</code>和<code>new</code>出来的对象的 ___proto__ 属性所指向的内存空间是一样的.</p><p>以<code>var arr = new Array();</code>为例说明这一点：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">arr</span><br><span class="line">[]&#123;</span><br><span class="line">  length: 0,</span><br><span class="line">  __proto__: Array(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">arr--&gt;|__proto__|sharedMenory((sharedMenory))</span><br><span class="line">Array--&gt;|prototype|sharedMenory</span><br></pre></td></tr></table></figure><p>那么我们new出来的对象怎么可以直接访问到这个共享空间的函数（如pop）呢？那是因为当访问对象下的属性时，如果在该对象下找不到，那么会一直往该对象下的<code>__proto__</code>属性下去找。</p><p>为什么说是一直往下找呢？因为发现<code>arr</code>对象下的<code>__proto__</code>属性其实是Array这个构造函数的原型——对象原型，这个原型本身也是个对象，是对象就应该有<code>__proto__</code>属性，也就是说，原型下还有另一个原型</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">arr.__proto__&#123;</span><br><span class="line">.....</span><br><span class="line">__proto__:Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开来看，这个原型就是<code>object</code></p><p>于是原型链的概念就此展开：</p><p>下图解释了一个<code>var arr = new Array();</code>  原型链，在看明白下图之前，要牢记一下几点</p><blockquote><ol><li>任意函数都有一个prototype属性，当然包括所谓的构造函数</li><li>任意对象都有<code>__proto__</code>属性。constructor是在该属性下</li><li>函数本身是Function对象</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">arr(arr&amp;ltobj&amp;gt)--&gt;|__proto__|ArrObj(Array&amp;ltobject&amp;gt)</span><br><span class="line">arr--&gt;|constructor|ArrayFun(Array&amp;lt&amp;nbspfunction&amp;nbsp&amp;gt)</span><br><span class="line">ArrObj--&gt;|constructor|ArrayFun</span><br><span class="line">ArrayFun--&gt;|prototype|ArrObj</span><br><span class="line">ArrObj--&gt;|__proto__|Object((Object&amp;ltobject&amp;gt))</span><br><span class="line"></span><br><span class="line">ArrayFun--&gt;|constructor|functionFunction(Function&amp;ltfunction&amp;gt)</span><br><span class="line">functionFunction--&gt;|prototype/__proto__|functionObject(Function&amp;ltobject&amp;gt)</span><br><span class="line">functionObject--&gt;|constructor|functionFunction</span><br><span class="line">functionFunction--&gt;|constructor|functionFunction</span><br><span class="line">ArrayFun--&gt;|__proto__|functionObject</span><br><span class="line">functionObject--&gt;|__proto__|Object</span><br><span class="line"></span><br><span class="line">Object--&gt;|constructor|objectFunction(Object&amp;ltfunction&amp;gt)</span><br><span class="line">objectFunction--&gt;|prototype|Object</span><br></pre></td></tr></table></figure><h2 id="js-oop-继承"><a class="markdownIt-Anchor" href="#js-oop-继承"></a> JS OOP 继承</h2><blockquote><p>在了解原型的概念后，我们发现<code>new</code>关键字还会干一件事[^1]，就是将构造函数的原型赋给对象的__proto__ 属性下</p></blockquote><blockquote><p>在了解原型链后，我们发现__proto__ 存在继承关系，似乎给了我们用JS实现继承提供了思路，但似乎又不那么简单！！</p></blockquote><p>如果一个构造函数 <code>fn.prototype = Array.prototype</code> 那么由该构造函数创建出来的对象自然有Array原型里的函数，看似实现了继承但是问题在于：</p><ol><li>fn 的 prototype和Array的prototype指向同一空间，如果往fn的原型里添加内容，直接影响了Array的原型！</li><li>只继承了公有方法，没有属性的继承</li></ol><p>因此我们希望的是实现类似下面的继承关系（子类有自己的属性和方法的情况下继承父类的属性和方法）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name,age,job</span>)</span>&#123;<span class="keyword">this</span>.job = job;&#125;</span><br><span class="line">Worker.prototype.getJob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.job;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'aaa'</span>,<span class="number">20</span>,<span class="string">'student'</span>)</span><br></pre></td></tr></table></figure><p>如果构造函数Worker 要继承构造函数 Person，从原型链角度分析，就应该是这样子的：  worker  --&gt;  worker 原型  --&gt; Person原型 --&gt; Object原型</p><p>而本身worker 的原型链是这样子的   worker --&gt; worker原型 --&gt; Object 原型</p><p>因此要实现继承关系，只需要将worker原型下的<code>__proto__</code> 指向Object 原型即可，也就是说，我们可以尝试在Worker构造函数里做这样的事。（可以尝试设想是否可以直接在new关键字执行时完成继承呢？）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  Worker.prototype.__proto__ = Person.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据之前得到的<code>new</code>关键字的结论，我们可以改写一下，通俗一些</p><p>这样似乎既继承了属性又继承了方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  Worker.prototype = <span class="keyword">new</span> Person(name,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>想法是好的，现实很那个</strong></p></blockquote><p>结果是，对象worker 的原型链并没有变，但是确实Worker 构造函数的原型确实指向了指定的Person对象了呀！</p><p>其实这个结论就是： <code>new</code>关键字的这个操作[^1]，**是在构造函数刚执行时创建的！！**那么，我们是不是可以重新指向__proto__呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.__proto__ = <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="comment">// 这样Person的原型就能精确挂在worker对象的 __proto__的__proto__下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实完美解决了！！</p><p>当然只是一般不会这么写</p><p>毕竟<code>__proto__</code>变量设计时的意义就是私有变量，只是ES5没有变量访问控制罢了…</p><p>所以一般还是写出来吧~~</p><h3 id="组合继承方法"><a class="markdownIt-Anchor" href="#组合继承方法"></a> 组合继承方法：</h3><p>用call来继承属性，用prototype继承方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>,name,age);</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Worker.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 这一步会在Worker原型上多两个undef变量，只是访问时一般被屏蔽</span></span><br><span class="line">Worker.prototype.constructor = Worker;</span><br><span class="line">Worker.prototype.getJob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.job;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'aaa'</span>,<span class="number">20</span>,<span class="string">'student'</span>)</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a class="markdownIt-Anchor" href="#原型式继承"></a> 原型式继承：</h3><p>先借助于已有对象创建新对象，在对该对象实现新属性和方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个原理就引出了**Object.create()**函数的作用了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Person(<span class="string">'abc'</span>,<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a class="markdownIt-Anchor" href="#寄生式继承"></a> 寄生式继承：</h3><p>其实就是自己写一个函数，利用原生式继承的原理，代替new创建继承对象。</p><h3 id="寄生组合式继承"><a class="markdownIt-Anchor" href="#寄生组合式继承"></a> 寄生组合式继承</h3><p>实际上就是解决组合式继承的弊端实现的一个<strong>继承封装</strong>，而且这个封装其实很简单</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js-oop对象"><a class="markdownIt-Anchor" href="#js-oop对象"></a> JS OOP对象</h2><h3 id="对象下属性和方法"><a class="markdownIt-Anchor" href="#对象下属性和方法"></a> 对象下属性和方法</h3><ol><li>isPrototypeOf(obj):</li><li>hasOwnProperty(attr_str):</li><li>propertyIsEnumerable(attr_str): 对象下的属性是否可以用for in 循环出来（因为有些内置的属性会隐藏起来不让遍历）</li><li>setter 和  getter函数</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  _name: <span class="string">'haha'</span>;</span><br><span class="line">  get name()&#123;</span><br><span class="line">  alert(<span class="string">'ok'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set name(val)&#123;</span><br><span class="line">    alert(<span class="string">'good'</span>)</span><br><span class="line">    <span class="keyword">this</span>.name = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.name; <span class="comment">// 触发函数，弹窗ok</span></span><br><span class="line">obj.name = <span class="string">'jiba'</span> <span class="comment">// 触发函数，弹窗good</span></span><br></pre></td></tr></table></figure><ol start="5"><li><code>__defineGetter__('attr_str',function)</code>和 <code>__defineSetter__('attr_str',function)</code> 函数</li></ol><blockquote><p>在对象定义后给对象添加getter或setter方法要通过两个特殊的方法</p><p><strong>defineGetter</strong> 和 <strong>defineSetter</strong> 。这两个函数要求第一个是</p><p>setter的名称，以string给出，第二个参数是作为getter或setter的函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="comment">//_name : '二狗',</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.__defineGetter__(<span class="string">'name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._name&#125;);<span class="comment">//定</span></span><br><span class="line">义 get name</span><br><span class="line">obj.__defineSetter__(<span class="string">'name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123; <span class="keyword">this</span>._name = va</span><br><span class="line">l&#125;);<span class="comment">//set name</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.name );<span class="comment">//'二狗'</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.name = <span class="string">'小黑'</span> );<span class="comment">//'小黑'</span></span><br></pre></td></tr></table></figure><ol start="6"><li><code>__lookupGetter__('attr_str')</code> 和  <code>__lookupGetter__('attr_str')</code>  函数 返回对象下该属性所对应的函数</li></ol><h3 id="object下的属性和方法"><a class="markdownIt-Anchor" href="#object下的属性和方法"></a> Object下的属性和方法</h3><ol start="7"><li><p>Object.defineProperties(O,[prop,]descriptors)  定义属性</p><ul><li>O 已有对象</li><li>Prop 为属性</li><li>descriptor 为属性描述符</li><li>descriptors  为多个属性描述符</li></ul><p>所谓属性描述符，就是该属性有什么特征（句柄）通常有那么几种</p><ul><li><code>value:</code> 属性值，默认<code>undefined</code></li><li><code>writable :</code> 是否可写  默认 <code>false</code></li><li><code>enumerable :</code> 是否可以被for in 枚举出来 默认 <code>false</code></li><li><code>configurable :</code> 是否可以被删除  默认 <code>false</code></li></ul><p>​</p><blockquote><p><strong>添加单个属性并属性特征方法</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o =&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'age'</span>, &#123;</span><br><span class="line">  value: <span class="number">24</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">alert(o.age);<span class="comment">//24</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>对多个属性设置描述符的方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o =&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o,&#123;</span><br><span class="line">age:&#123;</span><br><span class="line">  value: <span class="number">24</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">name:&#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>同时可以利用这个方法来为添加的属性添加get&amp;set函数</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj,&#123;</span><br><span class="line">  name:&#123;</span><br><span class="line">    value: <span class="string">'haha'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  sex&#123;</span><br><span class="line">  get()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;,</span><br><span class="line">set(val)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Object.getOwnPropertyDescriptor(O,property)</p><blockquote><p><strong>获取</strong>对象自有（非继承）属性的 <strong>属性描述符</strong></p></blockquote><p>​</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Des = <span class="keyword">var</span> Des = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'hello'</span>);</span><br><span class="line">alert(Des);<span class="comment">//&#123;value: undefined, writable: true, enumerable: true,configurable: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.keys(O,property)</p><blockquote><p>获取所有可枚举的非继承属性名，返回str数组</p></blockquote></li><li><p>Object.getOwnPropertyNames(O)</p></li></ol><blockquote><p><strong>获取所有自有（非继承）属性名</strong></p></blockquote><ol start="11"><li><p>Object.create(O,descriptors)</p><blockquote><p>之前介绍过，<strong>创建一个继承对象</strong>，这里还隐藏了第二个参数在这里介绍，意味着创建的对象同时可以__设置多个属性描述符__</p></blockquote></li></ol><h4 id="font-stylecolor-red控制对象属性的访问扩展删除密封更改冻结font"><a class="markdownIt-Anchor" href="#font-stylecolor-red控制对象属性的访问扩展删除密封更改冻结font"></a> <font style="color: red">控制对象属性的访问（扩展，删除【密封】，更改【冻结】）</font></h4><ol start="12"><li><p><code>Object.preventExtensions(O)</code> &amp;&amp; <code>Object.isExtensible(O)</code></p><blockquote><p><strong>阻止对象扩展，不能添加新属性</strong>，但是仍可以更改属性，删除属性</p></blockquote></li><li><p>Object.seal(O) / Object.isSealed()</p><blockquote><p>Object.seal( O ) 方法用于把对象 密封 ，也就是让对象既不可以拓展也不可以删<br>除属性（把每个属性的 configurable 设为false）,单数属性值仍然可以修改，<br>Object.isSealed（） 由于判断对象是否被密封</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(o);</span><br><span class="line">o.age = <span class="number">25</span>; <span class="comment">//仍然可以修改</span></span><br><span class="line"><span class="keyword">delete</span> o.age; <span class="comment">//Cannot delete property 'age' of &lt;Object&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.freeze(O) / Object.isFrozen()</p><blockquote><p>终极神器，完全 冻结对象 ，在seal的基础上，属性值也不可以修改（每个属性的<br>wirtable 也被设为 false ）</p></blockquote></li></ol><h2 id="oop-对象下的this指向问题"><a class="markdownIt-Anchor" href="#oop-对象下的this指向问题"></a> OOP 对象下的this指向问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javascript-初级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#javascript-初级&quot;&gt;&lt;/a&gt; JavaScript 初级&lt;/h1&gt;
&lt;h2 id=&quot;基础通识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;
      
    
    </summary>
    
      <category term="web开发" scheme="http://www.it120cc.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端开发" scheme="http://www.it120cc.com/categories/web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javascript" scheme="http://www.it120cc.com/categories/web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/"/>
    
    
      <category term="javascript" scheme="http://www.it120cc.com/tags/javascript/"/>
    
  </entry>
  
</feed>
